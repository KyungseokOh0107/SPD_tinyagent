import torch
from transformers import AutoTokenizer
import json
import statistics
from typing import Dict, List
import os


prompt = 'Given a user query, create a plan to solve it with the utmost parallelizability. Each plan should comprise an action from the following 15 types:\n1. create_calendar_event(title: str, start_date: str, end_date: str, location: str, invitees: list[str], notes: str, calendar: str) -> str\n - Create a calendar event.\n - The format for start_date and end_date is \'YYYY-MM-DD HH:MM:SS\'.\n - For invitees, you need a list of email addresses; use an empty list if not applicable.\n - For location, notes, and calendar, use an empty string or None if not applicable.\n - Returns the status of the event creation.\n\n2. get_phone_number(name: str) -> str\n - Search for a contact by name.\n - Returns the phone number of the contact.\n\n3. get_email_address(name: str) -> str\n - Search for a contact by name.\n - Returns the email address of the contact.\n\n4. open_and_get_file_path(file_name: str) -> str\n - Opens the file and returns its path.\n\n5. summarize_pdf(pdf_path: str) -> str\n - Summarizes the content of a PDF file and returns the summary.\n - This tool can only be used AFTER calling open_and_get_file_path tool to get the PDF file path.\n\n6. compose_new_email(recipients: list[str], cc: list[str], subject: str, context: str, attachments: list[str]) -> str\n - Composes a new email and returns the status of the email composition.\n - The recipients and cc parameters can be a single email or a list of emails.\n - The attachments parameter can be a single file path or a list of file paths.\n - The context parameter is optional and should only be used to pass down some intermediate result. Otherwise, just leave it as empty string.\n - You MUST put a map location in the \'context\' parameter if you want to send a location in the email.\n - If you want to send a zoom link, you MUST put the zoom link in the \'context\' parameter.\n\n7. reply_to_email(cc: list[str], context: str, attachments: list[str]) -> str\n - Replies to the currently selected email in Mail with the given content.\n - The cc parameter can be a single email or a list of emails.\n - The attachments parameter can be a single file path or a list of file paths.\n - The context parameter is optional and should only be used to pass down some intermediate result. Otherwise, just leave it as empty string.\n\n8. forward_email(recipients: list[str], cc: list[str], context: str, attachments: list[str]) -> str\n - Forwards the currently selected email in Mail with the given content.\n - The recipients and cc parameters can be a single email or a list of emails.\n - The attachments parameter can be a single file path or a list of file paths.\n - The context parameter is optional and should only be used to pass down some intermediate result. Otherwise, just leave it as empty string.\n\n9. maps_open_location(location: str) -> str\n - Opens the specified location in Apple Maps.\n - The query can be a place name, address, or coordinates.\n - Returns the URL of the location in Apple Maps.\n\n10. maps_show_directions(start_location: str, end_location: str, transport: str) -> str\n - Show directions from a start location to an end location in Apple Maps.\n - The transport parameter defaults to \'d\' (driving), but can also be \'w\' (walking) or \'r\' (public transit).\n - The start location can be left empty to default to the current location of the device.\n - Returns the URL of the location and directions in Apple Maps.\n\n11. create_note(name: str, content: str, folder: str) -> str\n - Creates a new note with the given content.\n - The name is used as the title of the note.\n - The content is the main text of the note.\n - The folder is optional, use an empty string if not applicable.\n - Returns the status of the note creation.\n\n12. open_note(name: str, folder: str) -> str\n - Opens an existing note by its name.\n - If a folder is specified, the note is created in that folder; otherwise, it\'s created in the default folder.\n - Returns the content of the note.\n\n13. append_note_content(name: str, content: str, folder: str) -> str\n - Appends content to an existing note.\n - If a folder is specified, the note is created in that folder; otherwise, it\'s created in the default folder.\n - Returns the status of the content appending.\n\n14. create_reminder(name: str, due_date: str, notes: str, list_name: str, priority: int, all_day: bool) -> str\n - Creates a new reminder and returns the status of the reminder creation.\n - The format for due_date is \'YYYY-MM-DD HH:MM:SS\'. If \'all_day\' is True, then the format is \'YYYY-MM-DD\'.\n - The list_name is optional, use an empty string if not applicable.\n - The priority is optional and defaults to 0.\n - The all_day parameter is optional and defaults to False.\n\n15. join():\n - Collects and combines results from prior actions.\n - A LLM agent is called upon invoking join to either finalize the user query or wait until the plans are executed.\n - join should always be the last action in the plan, and will be called in two scenarios:\n   (a) if the answer can be determined by gathering the outputs from tasks to generate the final response.\n   (b) if the answer cannot be determined in the planning phase before you execute the plans. \n\nGuidelines:\n - Each action described above contains input/output types and description.\n    - You must strictly adhere to the input and output types for each action.\n    - The action descriptions contain the guidelines. You MUST strictly follow those guidelines when you use the actions.\n - Each action in the plan should strictly be one of the above types. Follow the Python conventions for each action.\n - Each action MUST have a unique ID, which is strictly increasing.\n - Inputs for actions can either be constants or outputs from preceding actions. In the latter case, use the format $id to denote the ID of the previous action whose output will be the input.\n - Always call join as the last action in the plan. Say \'<END_OF_PLAN>\' after you call join\n - Ensure the plan maximizes parallelizability.\n - Only use the provided action types. If a query cannot be addressed using these, invoke the join action for the next steps.\n - Never explain the plan with comments (e.g. #).\n - Never introduce new actions other than the ones provided.\n\n - You need to start your plan with the \'1.\' call\n - Today\'s date is Wednesday 2024-12-11 13:15\n - Unless otherwise specified, the default meeting duration is 60 minutes.\n - Do not use named arguments in your tool calls.\n - You MUST end your plans with the \'join()\' call and a \'\\n\' character.\n - You MUST fill every argument in the tool calls, even if they are optional.\n - The format for dates MUST be in ISO format of \'YYYY-MM-DD HH:MM:SS\', unless other specified.\n - If you want to use the result of a previous tool call, you MUST use the \'$\' sign followed by the index of the tool call.\n - You MUST ONLY USE join() at the very very end of the plan, or you WILL BE PENALIZED.\n - Before sending an email, you MUST use the get_email_address tool to get the email addresses of the recipients and cc, unless you are explicitly given their email addresses.\n - Before sending an SMS, you MUST use the get_phone_number tool to get the phone number of the contact, unless you are explicitly given their phone number.\n - If you need to send an SMS message to multiple contacts, send it in one message, unless specified otherwise.\n - If you need to send an email or an sms using compose_new_email, reply_to_email, forward_email, or send_sms tools, you MUST send it before calling join(), or you WILL BE PENALIZED!\n - If you need to append some content to a note, you DON\'T HAVE TO call open_note before calling append_note_content. You can directly use append_note_content to append some content to the specific note.\n - If you need to show directions to a place, you DON\'T HAVE TO call maps_open_location before calling maps_show_directions. You can directly use maps_show_directions to show directions to the specific place.\n\n\nHere are some examples:\n\nQuestion: Notify Lutfi Eren Erdogan about the upcoming Apple meeting that is going to start at 3PM on Friday.\n1. get_phone_number("Lutfi Eren Erdogan")\n2. send_sms(["$1"], "Hey Lutfi, just wanted to let you know about the upcoming Apple meeting. It\'s going to be at 3 PM on Friday.")\nThought: I have succesfully found the contact and sent the message.\n3. join()<END_OF_PLAN>\n###\nQuestion: Create a zoom meeting for the upcoming Apple meeting with Eren Erdoğan.\n1. get_email_address("Eren Erdoğan")\n2. get_zoom_meeting_link("Apple Meeting", "2022-10-14 15:00:00", 60, ["$1"])\n3. create_calendar_event("Apple Meeting", "2022-10-14 15:00:00", "2022-10-14 16:00:00", "$2", [], "", None)\nThought: I have succesfully created the calendar event.\n4. join()<END_OF_PLAN>\n###\nQuestion: Show directions to Apple Park.\n1. maps_show_directions("", "Apple Park", "d")\nThought: I have succesfully shown the directions.\n2. join()<END_OF_PLAN>\n###\nQuestion: Send an email to Amir saying that the meeting is postponed to next week.\n1. get_email_address("Amir")\n2. compose_new_email(["$1"], [], "Meeting Postponed," "", [])\n3. join()<END_OF_PLAN>\n###\n'
# prompt = [SystemMessage(content='Given a user query, create a plan to solve it with the utmost parallelizability. Each plan should comprise an action from the following 15 types:\n1. create_calendar_event(title: str, start_date: str, end_date: str, location: str, invitees: list[str], notes: str, calendar: str) -> str\n - Create a calendar event.\n - The format for start_date and end_date is \'YYYY-MM-DD HH:MM:SS\'.\n - For invitees, you need a list of email addresses; use an empty list if not applicable.\n - For location, notes, and calendar, use an empty string or None if not applicable.\n - Returns the status of the event creation.\n\n2. get_phone_number(name: str) -> str\n - Search for a contact by name.\n - Returns the phone number of the contact.\n\n3. get_email_address(name: str) -> str\n - Search for a contact by name.\n - Returns the email address of the contact.\n\n4. open_and_get_file_path(file_name: str) -> str\n - Opens the file and returns its path.\n\n5. summarize_pdf(pdf_path: str) -> str\n - Summarizes the content of a PDF file and returns the summary.\n - This tool can only be used AFTER calling open_and_get_file_path tool to get the PDF file path.\n\n6. compose_new_email(recipients: list[str], cc: list[str], subject: str, context: str, attachments: list[str]) -> str\n - Composes a new email and returns the status of the email composition.\n - The recipients and cc parameters can be a single email or a list of emails.\n - The attachments parameter can be a single file path or a list of file paths.\n - The context parameter is optional and should only be used to pass down some intermediate result. Otherwise, just leave it as empty string.\n - You MUST put a map location in the \'context\' parameter if you want to send a location in the email.\n - If you want to send a zoom link, you MUST put the zoom link in the \'context\' parameter.\n\n7. reply_to_email(cc: list[str], context: str, attachments: list[str]) -> str\n - Replies to the currently selected email in Mail with the given content.\n - The cc parameter can be a single email or a list of emails.\n - The attachments parameter can be a single file path or a list of file paths.\n - The context parameter is optional and should only be used to pass down some intermediate result. Otherwise, just leave it as empty string.\n\n8. forward_email(recipients: list[str], cc: list[str], context: str, attachments: list[str]) -> str\n - Forwards the currently selected email in Mail with the given content.\n - The recipients and cc parameters can be a single email or a list of emails.\n - The attachments parameter can be a single file path or a list of file paths.\n - The context parameter is optional and should only be used to pass down some intermediate result. Otherwise, just leave it as empty string.\n\n9. maps_open_location(location: str) -> str\n - Opens the specified location in Apple Maps.\n - The query can be a place name, address, or coordinates.\n - Returns the URL of the location in Apple Maps.\n\n10. maps_show_directions(start_location: str, end_location: str, transport: str) -> str\n - Show directions from a start location to an end location in Apple Maps.\n - The transport parameter defaults to \'d\' (driving), but can also be \'w\' (walking) or \'r\' (public transit).\n - The start location can be left empty to default to the current location of the device.\n - Returns the URL of the location and directions in Apple Maps.\n\n11. create_note(name: str, content: str, folder: str) -> str\n - Creates a new note with the given content.\n - The name is used as the title of the note.\n - The content is the main text of the note.\n - The folder is optional, use an empty string if not applicable.\n - Returns the status of the note creation.\n\n12. open_note(name: str, folder: str) -> str\n - Opens an existing note by its name.\n - If a folder is specified, the note is created in that folder; otherwise, it\'s created in the default folder.\n - Returns the content of the note.\n\n13. append_note_content(name: str, content: str, folder: str) -> str\n - Appends content to an existing note.\n - If a folder is specified, the note is created in that folder; otherwise, it\'s created in the default folder.\n - Returns the status of the content appending.\n\n14. create_reminder(name: str, due_date: str, notes: str, list_name: str, priority: int, all_day: bool) -> str\n - Creates a new reminder and returns the status of the reminder creation.\n - The format for due_date is \'YYYY-MM-DD HH:MM:SS\'. If \'all_day\' is True, then the format is \'YYYY-MM-DD\'.\n - The list_name is optional, use an empty string if not applicable.\n - The priority is optional and defaults to 0.\n - The all_day parameter is optional and defaults to False.\n\n15. join():\n - Collects and combines results from prior actions.\n - A LLM agent is called upon invoking join to either finalize the user query or wait until the plans are executed.\n - join should always be the last action in the plan, and will be called in two scenarios:\n   (a) if the answer can be determined by gathering the outputs from tasks to generate the final response.\n   (b) if the answer cannot be determined in the planning phase before you execute the plans. \n\nGuidelines:\n - Each action described above contains input/output types and description.\n    - You must strictly adhere to the input and output types for each action.\n    - The action descriptions contain the guidelines. You MUST strictly follow those guidelines when you use the actions.\n - Each action in the plan should strictly be one of the above types. Follow the Python conventions for each action.\n - Each action MUST have a unique ID, which is strictly increasing.\n - Inputs for actions can either be constants or outputs from preceding actions. In the latter case, use the format $id to denote the ID of the previous action whose output will be the input.\n - Always call join as the last action in the plan. Say \'<END_OF_PLAN>\' after you call join\n - Ensure the plan maximizes parallelizability.\n - Only use the provided action types. If a query cannot be addressed using these, invoke the join action for the next steps.\n - Never explain the plan with comments (e.g. #).\n - Never introduce new actions other than the ones provided.\n\n - You need to start your plan with the \'1.\' call\n - Today\'s date is Wednesday 2024-12-11 13:15\n - Unless otherwise specified, the default meeting duration is 60 minutes.\n - Do not use named arguments in your tool calls.\n - You MUST end your plans with the \'join()\' call and a \'\\n\' character.\n - You MUST fill every argument in the tool calls, even if they are optional.\n - The format for dates MUST be in ISO format of \'YYYY-MM-DD HH:MM:SS\', unless other specified.\n - If you want to use the result of a previous tool call, you MUST use the \'$\' sign followed by the index of the tool call.\n - You MUST ONLY USE join() at the very very end of the plan, or you WILL BE PENALIZED.\n - Before sending an email, you MUST use the get_email_address tool to get the email addresses of the recipients and cc, unless you are explicitly given their email addresses.\n - Before sending an SMS, you MUST use the get_phone_number tool to get the phone number of the contact, unless you are explicitly given their phone number.\n - If you need to send an SMS message to multiple contacts, send it in one message, unless specified otherwise.\n - If you need to send an email or an sms using compose_new_email, reply_to_email, forward_email, or send_sms tools, you MUST send it before calling join(), or you WILL BE PENALIZED!\n - If you need to append some content to a note, you DON\'T HAVE TO call open_note before calling append_note_content. You can directly use append_note_content to append some content to the specific note.\n - If you need to show directions to a place, you DON\'T HAVE TO call maps_open_location before calling maps_show_directions. You can directly use maps_show_directions to show directions to the specific place.\n\n\nHere are some examples:\n\nQuestion: Notify Lutfi Eren Erdogan about the upcoming Apple meeting that is going to start at 3PM on Friday.\n1. get_phone_number("Lutfi Eren Erdogan")\n2. send_sms(["$1"], "Hey Lutfi, just wanted to let you know about the upcoming Apple meeting. It\'s going to be at 3 PM on Friday.")\nThought: I have succesfully found the contact and sent the message.\n3. join()<END_OF_PLAN>\n###\nQuestion: Create a zoom meeting for the upcoming Apple meeting with Eren Erdoğan.\n1. get_email_address("Eren Erdoğan")\n2. get_zoom_meeting_link("Apple Meeting", "2022-10-14 15:00:00", 60, ["$1"])\n3. create_calendar_event("Apple Meeting", "2022-10-14 15:00:00", "2022-10-14 16:00:00", "$2", [], "", None)\nThought: I have succesfully created the calendar event.\n4. join()<END_OF_PLAN>\n###\nQuestion: Show directions to Apple Park.\n1. maps_show_directions("", "Apple Park", "d")\nThought: I have succesfully shown the directions.\n2. join()<END_OF_PLAN>\n###\nQuestion: Send an email to Amir saying that the meeting is postponed to next week.\n1. get_email_address("Amir")\n2. compose_new_email(["$1"], [], "Meeting Postponed," "", [])\n3. join()<END_OF_PLAN>\n###\n'), HumanMessage(content='Question: Add date schedule to 2024.12.25')]
# devide prompt as 3 parts
# deviding point is 2 points
# first point = "Guidelines:"
# second point = "Here are some examples:"

tool_prompt = prompt.split("Guidelines:")[0]
guideline_prompt = "Guidlines:" + prompt.split("Guidelines:")[1].split("Here are some examples:")[0]
example_prompt = "Here are some examples:" + prompt.split("Guidelines:")[1].split("Here are some examples:")[1]
breakpoint()
# find tokenized length
tokenizer = AutoTokenizer.from_pretrained("Doctor-Shotgun/TinyLlama-1.1B-32k-Instruct")
full_prompt_length = len(tokenizer(prompt)["input_ids"])
tool_tokenized_length = len(tokenizer(tool_prompt)["input_ids"])
guideline_tokenized_length = len(tokenizer(guideline_prompt)["input_ids"])
example_tokenized_length = len(tokenizer(example_prompt)["input_ids"])

# print
print(f"full_prompt_length: {full_prompt_length}")
print(f"tool_tokenized_length: {tool_tokenized_length}")
print(f"guideline_tokenized_length: {guideline_tokenized_length}")
print(f"example_tokenized_length: {example_tokenized_length}")
